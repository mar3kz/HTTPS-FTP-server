#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h> // systemove veci (read/write/close), procesy (fork/exec), slozky (chdir), F_OK...
#include <fcntl.h>  // systemove veci, procesy, uzivatele&skupiny (getuid), flags pro open()
#include <sys/types.h> // data type of password struct
#include <pwd.h>       // password struct
#include <sys/stat.h> // S_ISDIR(), stat struktura, stat
#include <dirent.h> // DIR
#include <ctype.h> // isdigit, isaplha, isupper, is...


// https://pubs.opengroup.org/onlinepubs/7908799/xsh/pwd.h.html
// https://www.qnx.com/developers/docs/8.0/com.qnx.doc.neutrino.lib_ref/topic/g/getpwnam.html
// https://stackoverflow.com/questions/2256945/removing-a-non-empty-directory-programmatically-in-c-or-c
// https://www.oreilly.com/library/view/c-in-a/0596006977/re194.html
// https://www.mkssoftware.com/docs/man5/struct_stat.5.asp
// https://pubs.opengroup.org/onlinepubs/009604599/functions/opendir.html

// reentrant function - ???
// pozor [x][x] => %c; [x] => %s
// vypsání velikosti memory page => getpagesize()
// flags = vlastnosti (v kontextu macros)
// stat struktura poskytuje detailni informace o souborech, funkce stat() ji naplni
// makro S_ISDIR() se pouziva na zjisteni, jestli je soubor slozka, bere jako argument cast struktury stat (st_mode) - flags (vlastnosti souboru)

// rm -s path => [0] = rm, [1] = -s, [2] = path
// cd path => [0] = cd, [1] = path, [2] = 0

// open, read, write je pro soubory, pro open je dulezite dat jako argumenty: (path, flags, execution permissions)
// opendir, closedir, readdir je pro slozky => potreba inicializace a deklarace pointeru na strukturu dirent (pointer, protoze je to vice efektivni)
// stream = koncept, ktery nam umoznuje praci s daty - cteni/zapisovani do ruznych zdroju
// access funkkce F_OK

/*
┌──(marek㉿kali)-[~/Documents]
└─$ cat /proc/1/stat
1 (systemd) S 0 1 1 0 -1 4194560 14032 157220 109 512 52 201 726 1865 20 0 1 0 61 23031808 3442 18446744073709551615 1 1 0 0 0 0 671173123 4096 1260 0 0 0 17 0 0 0 0 0 0 0 0 0 0 0 0 0 0
pid, nazev, stav, ..., tato hodnota znamena, jestli je ten proces pripojen k nejakemu terminalu
*/

// funkce fscanf vraci EOF pokud je error a pocet prvku, ktere potrebujeme, pokud je to spravne
// proces, ktery neni pripojen k zadnemu terminalu tam bude mit -1 a proces, ktery je pripojen k nejakemu terminalu tam bude mit cislo vetsi nez 0, 1 => /dev/tty1 = virtuální terminál 1, coz
// zname, ze pokud bychom chteli komunikovat s tim pocitacem jenom pomoci CLI, tak pro to jsou urceny ty terminaly
// funkce isaplha zjisti, jestli je x. prvek pismeno a funkce isdigit zjisti, jestli je x. prvek cislo

// ps -eo pid,tty,command

// funkce fscanf - vraci pocet uspesne nactenych polozek, neco se precte a kurzor zustane za tim prectenym prvkem

#define ROWS 3
#define COLUMNS 40

char **split(char *command);
char *input();
void free2D_arr(char **p_2D_arr);
int isDir(char *path);
int delete_filesDirectories(char **input);
int nestedFilesDeletion(char *nestedPath);
int my_mkdir(char **input);
int my_rmdir(char **input);
int ls(char **input);
int readingProcesses();
char nestedReadingStat(char *processes);
int isConnectedToTty(char *process);
char *uidToName(char *process);
void encrypt(int offset, char *toEncrypt);
void find(char *objectToFind, char *path);

int *num_chars;
char *officialPathForRm;
char lastUsedCommand[50];

int main(int argc, char *argv[])
{
   int RUID = getuid();
   char currentDir[50];
   char commandToExecute[50];

   struct passwd *p_pw;

   if ( (p_pw = getpwuid(RUID)) == NULL)
   {
       fprintf(stderr, "no user matching your RUID\n");
       exit(1);
   }
   printf("\n\n\n\n\n----(%s)-[%s]\n$ ", p_pw->pw_name, getcwd(currentDir, sizeof(currentDir)) );

   char *input_arr = input(); // 49 chars + \0, pokud vice nez 49 chars, tak zbytkove chars budou v stdin => nutny flush stdin bufferu

   char **array_2D = split(input_arr);



   // char *(*p_input)() = input; // function pointer, ktery ukazuje na funkci, ktera nema zadny parametr, input = pointer na fu